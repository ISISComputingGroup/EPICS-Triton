InTerminator = LF;
OutTerminator = CR LF;

#
# Throughout this file, if protocol entries require an argument it will always be the device prefix $(P)
#
# PVs have to be hardcoded in this file as there is a length limit on input links which gets exceeded
#

getMCUid {
    out "READ:SYS:DR:CHAN:MC";
	in "STAT:SYS:DR:CHAN:MC:%s";
}

getMCTemp {
    out "READ:DEV:%(\$1MC:UID)s:TEMP:SIG:TEMP";
	in "STAT:DEV:%*[^:]:TEMP:SIG:TEMP:%fK";
}

getSTILUid {
    out "READ:SYS:DR:CHAN:STIL";
	in "STAT:SYS:DR:CHAN:STIL:%s";
}

getSTILTemp {
    out "READ:DEV:%(\$1STIL:UID)s:TEMP:SIG:TEMP";
	in "STAT:DEV:%*[^:]:TEMP:SIG:TEMP:%fK";
}

getSORBUid {
    out "READ:SYS:DR:CHAN:SORB";
	in "STAT:SYS:DR:CHAN:SORB:%s";
}

getSORBTemp {
    out "READ:DEV:%(\$1SORB:UID)s:TEMP:SIG:TEMP";
	in "STAT:DEV:%*[^:]:TEMP:SIG:TEMP:%fK";
}

setP {
    out "SET:DEV:%(\$1MC:UID)s:TEMP:LOOP:P:%f";
}

getP {
    out "READ:DEV:%(\$1MC:UID)s:TEMP:LOOP:P";
    in "STAT:DEV:%*[^:]:TEMP:LOOP:P:%f";
}

setI {
    out "SET:DEV:%(\$1MC:UID)s:TEMP:LOOP:I:%f";
}

getI {
    out "READ:DEV:%(\$1MC:UID)s:TEMP:LOOP:I";
    in "STAT:DEV:%*[^:]:TEMP:LOOP:I:%f";
}

setD {
    out "SET:DEV:%(\$1MC:UID)s:TEMP:LOOP:D:%f";
}

getD {
    out "READ:DEV:%(\$1MC:UID)s:TEMP:LOOP:D";
    in "STAT:DEV:%*[^:]:TEMP:LOOP:D:%f";
}

setTSetpoint {
   out "SET:DEV:%(\$1MC:UID)s:TEMP:LOOP:TSET:%f";
}

getTSetpoint {
    out "READ:DEV:%(\$1MC:UID)s:TEMP:LOOP:TSET";
    in "STAT:DEV:%*[^:]:TEMP:LOOP:TSET:%fK";
}

setHtrRange {
   out "SET:DEV:%(\$1MC:UID)s:TEMP:LOOP:RANGE:%f";
}

getHtrRange {
    out "READ:DEV:%(\$1MC:UID)s:TEMP:LOOP:RANGE";
    in "STAT:DEV:%*[^:]:TEMP:LOOP:RANGE:%f";
}

getHtrType {
    out "READ:DEV:%(\$1MC:UID)s:TEMP:LOOP:HTR";
    in "STAT:DEV:%*[^:]:TEMP:LOOP:HTR:%s";
}

getHtrPower {
    out "READ:DEV:%(\$1HEATER:TYPE)s:HTR:SIG:POWR";
	in "STAT:DEV:%*[^:]:HTR:SIG:POWR:%f%(\$1HEATER:POWER.EGU)s";
}

getClosedLoop {
    out "READ:DEV:%(\$1MC:UID)s:TEMP:LOOP:MODE";
	in "STAT:DEV:%*[^:]:TEMP:LOOP:MODE:%{OFF|ON}";
}

setClosedLoop {
    out "SET:DEV:%(\$1MC:UID)s:TEMP:LOOP:MODE:%{OFF|ON}";
}

getValveState {
    # Argument 1 = Valve number
    out "READ:DEV:V\$1:VALV:SIG:STATE";
    in "STAT:DEV:V%*i:VALV:SIG:STATE:%{OPEN|CLOSE|NOT_FOUND}";
}

getChanState {
    # Argument 1 = Channel number
	out "READ:DEV:T\$1:TEMP:MEAS:ENAB";
	in "STAT:DEV:T%*i:TEMP:MEAS:ENAB:%{OFF|ON}";
}

setChanState {
    # Argument 1 = Channel number
    out "SET:DEV:T\$1:TEMP:MEAS:ENAB:%{OFF|ON}";
}

getStatus {
    out "READ:SYS:DR:STATUS";
	ExtraInput = Ignore;  # If we get more than 512 chars in response, discard the excess and do not throw an error.
	in "STAT:SYS:DR:STATUS:%512c";
}

getAutomation {
    out "READ:SYS:DR:ACTN";
	ExtraInput = Ignore;  # If we get more than 512 chars in response, discard the excess and do not throw an error.
	in "STAT:SYS:DR:ACTN:%512c";
}

get4KHXTemp {
    out "READ:DEV:T3:TEMP:SIG:TEMP";
	in "STAT:DEV:T3:TEMP:SIG:TEMP:%fK";
}

getJTHXTemp {
    out "READ:DEV:T2:TEMP:SIG:TEMP";
	in "STAT:DEV:T2:TEMP:SIG:TEMP:%fK";
} 

getPressure {
    out "READ:DEV:\$1:PRES:SIG:PRES";
	in "STAT:DEV:\$1:PRES:SIG:PRES:%fmB";
}
